  @Post('createPropertyWalletInventoryStep1')
  @hasModulePermission(moduleType.inventories)
  create(@Body() createPropertyWalletInventoryDto: CreatePropertyWalletInventoryDto) {
    return this.propertyWalletInventoryService.create(createPropertyWalletInventoryDto);
  }


--------------------

  async create(createPropertyWalletInventoryDto: CreatePropertyWalletInventoryDto): Promise<ResponseDto> {
  const queryRunner = this.connection.createQueryRunner();
  await queryRunner.connect()
  await queryRunner.startTransaction()

  try {
    const repo = queryRunner.manager.getRepository(PropertyWalletInventory);
    const propertyWalletFilterationRepo = queryRunner.manager.getRepository(PropertyWalletFilteration);
    

    const userId = await this.adminAuth.getAdminUserId()
    createPropertyWalletInventoryDto['createdBy'] = userId

    const result = await repo.save(createPropertyWalletInventoryDto)
    await propertyWalletFilterationRepo.save({
      propertyWalletProjectId: createPropertyWalletInventoryDto.propertyWalletProjectId,
      propertyWalletInventoryId: result.id,
      projectTypeId: createPropertyWalletInventoryDto.projectTypeId,
      projectSubTypeId: createPropertyWalletInventoryDto.projectSubTypeId,
      landSize: createPropertyWalletInventoryDto.landSize,
      landAreaId: createPropertyWalletInventoryDto.landAreaId,
      price : createPropertyWalletInventoryDto.price
    })
    await queryRunner.commitTransaction()
    const data = await this.getProjectDetail(result.id)
    return { message: commonMessage.create, data: data};
  } 
  catch (error) {
    await queryRunner.rollbackTransaction();
    throw new InternalServerErrorException(error);
  }
   finally {
    await queryRunner.release();
  }
  } 







----------------
