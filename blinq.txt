import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { BlinqIntegrationService } from './blinq-integration.service';
import { CreateBlinqIntegrationDto, CreateBlinqInvoiceDto } from './dto/create-blinq-integration.dto';
import { UpdateBlinqIntegrationDto } from './dto/update-blinq-integration.dto';
import { ApiTags } from '@nestjs/swagger';

@ApiTags('blinq-integration')
@Controller({
  version : '1',
  path : 'blinq-integration'
})
export class BlinqIntegrationController {
  constructor(private readonly blinqIntegrationService: BlinqIntegrationService) {}

  @Post('/createInvoice')
  generateInvoice(@Body() createBlinqInvoiceDto : CreateBlinqInvoiceDto) {
    return this.blinqIntegrationService.generateInvoice(createBlinqInvoiceDto);
  }

  @Post('/invoiceIsPaidCallBack/:InvoiceNumber')
  invoiceIsPaidCallBack(@Param('InvoiceNumber') InvoiceNumber: string) {
    return this.blinqIntegrationService.invoiceIsPaidCallBack(InvoiceNumber);
  }


  
}





////


import { BadRequestException, Body, Injectable, InternalServerErrorException, Logger } from '@nestjs/common';
import { CreateBlinqIntegrationDto, CreateBlinqInvoiceDto } from './dto/create-blinq-integration.dto';
import { UpdateBlinqIntegrationDto } from './dto/update-blinq-integration.dto';
import { Connection, getRepository } from 'typeorm';
import { HttpService } from '@nestjs/axios';
import { map } from 'rxjs';
import { customAlphabet, nanoid } from 'nanoid';
import { BlinqIntegration } from './entities/blinq-integration.entity';
import { commonMessage } from 'src/common/messages';
import { blinqMessage } from 'src/common/blinqMessages';
import { Cron } from '@nestjs/schedule';
import { BlinqInvoice } from './entities/blinq-invoice.entity';
import { ResponseDto } from 'src/common/response.dto';

@Injectable()
export class BlinqIntegrationService {
  constructor(
    private readonly connection: Connection,
    private httpService: HttpService,
    ) { }
    blinqCredentials = {
        ClientID: process.env.Blinq_ClientID,
        ClientSecret: process.env.Blinq_ClientSecret
    };
    Blinq_BaseURL = process.env.Blinq_BaseURL || 'https://staging-api.blinq.pk';

  async createUniqueKey(){
      try {
          const nanoId = nanoid();
          const custom_alphabet = customAlphabet('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ', 30);
          const custom_alphabet_output = custom_alphabet();
          return { nanoId, custom_alphabet_output };
      } catch (error) {
          throw new InternalServerErrorException(error)
      }
  }
  async tokenGeneration(){
    const queryRunner = this.connection.createQueryRunner()
    await queryRunner.connect();
    queryRunner.startTransaction()
    try{
      const tokenRepo = queryRunner.manager.getRepository(BlinqIntegration)
      const body = this.blinqCredentials
      const data = await this.httpService.post(`${this.Blinq_BaseURL}/api/Auth`,body).toPromise()
      await tokenRepo.delete({})
      if(data.data === 'Authorized'){
        const token = await tokenRepo.insert({authToken : data.headers.token,expiry : +data.headers.tokenexpiry})
        if(token){
          queryRunner.commitTransaction()
          return {message : blinqMessage.tokenSuccess ,token : data.headers.token}
        }
      }
      throw new BadRequestException(blinqMessage.tokenFailed)
    }catch(error){
      queryRunner.rollbackTransaction()
      throw new InternalServerErrorException(error)
    }
  }

  async generateInvoice(createBlinqInvoiceDto : CreateBlinqInvoiceDto): Promise<ResponseDto>{
    const queryRunner = this.connection.createQueryRunner()
    queryRunner.connect()
    await queryRunner.startTransaction()
    try{
      const tokenRepo = queryRunner.manager.getRepository(BlinqIntegration)
      const invoiceRepo = queryRunner.manager.getRepository(BlinqInvoice)
      const invoiceObject = {
        InvoiceNumber : createBlinqInvoiceDto.InvoiceNumber,
        InvoiceAmount : createBlinqInvoiceDto.InvoiceAmount,
        InvoiceDueDate : createBlinqInvoiceDto.InvoiceDueDate,
        InvoiceType : createBlinqInvoiceDto.InvoiceType,
        IssueDate : createBlinqInvoiceDto.IssueDate,
        CustomerName : createBlinqInvoiceDto.CustomerName,
        Description : '',
        TranFee : 0,
        PaymentCode : '',
        oneBillID : '',
        IsFeeApplied: false,
        ClickToPayUrl: '',
        isPaid : false
      }
      const tokenData = await tokenRepo.find({})
      if(tokenData[0]){
        const invoice = await this.httpService.post(`${this.Blinq_BaseURL}/invoice/create`,
        [createBlinqInvoiceDto],{
          headers:{
            token : tokenData[0].authToken
          }
        }).toPromise()
        if(invoice?.data?.Status === blinqMessage.Success){
          invoiceObject.Description = invoice.data.ResponseDetail[0].Description
          invoiceObject.TranFee = +invoice.data.ResponseDetail[0].TranFee
          invoiceObject.PaymentCode = invoice.data.ResponseDetail[0].PaymentCode
          invoiceObject.oneBillID = invoice.data.ResponseDetail[0]['1BillID']
          invoiceObject.IsFeeApplied = invoice.data.ResponseDetail[0].IsFeeApplied
          invoiceObject.ClickToPayUrl = invoice.data.ResponseDetail[0].ClickToPayUrl
          const data  = await invoiceRepo.save(invoiceObject)
          await queryRunner.commitTransaction()
          return {message : blinqMessage.invoiceCreated , data : data.Description}
        }
        else{
          throw new InternalServerErrorException(invoice?.data?.Status)
        }
      }else{
        const data = await this.tokenGeneration()
        if(data.message === blinqMessage.tokenSuccess){
          await this.generateInvoice(createBlinqInvoiceDto)
        }
        else{
          throw new InternalServerErrorException(blinqMessage.ServiceFail)
        }
      }
    }catch(error){
      await queryRunner.rollbackTransaction()
      throw new InternalServerErrorException(error)
    }finally{
      await queryRunner.release()
    }
  }
  @Cron('0 */29 * * * *')
    async handleCron() {
      await this.tokenGeneration()
    }


    async invoiceIsPaidCallBack(InvoiceNumber : string): Promise<ResponseDto> {
      const queryRunner = this.connection.createQueryRunner()
      await queryRunner.connect();
      queryRunner.startTransaction()
      try {
        const invoiceRepo = queryRunner.manager.getRepository(BlinqInvoice)
        const result = await invoiceRepo.update({InvoiceNumber: InvoiceNumber }, {isPaid: true})
        queryRunner.commitTransaction()  
        return { message: commonMessage.get, data: result };

      } catch (error) {
        throw new InternalServerErrorException(error);
      }
    }




    }











