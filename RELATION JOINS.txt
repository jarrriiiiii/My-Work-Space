async getAvailableInventoriesByProjectId(ProjectId: number, page: number, limit: number): Promise<ResponseDto> {
  try {
    const convoRepo = getRepository(PropertyWalletProject);
    const convoList = await convoRepo
    .createQueryBuilder('con')
    .select([
      'con.id',
      'con.city',
      'propertyWalletInventory.price',
      'propertyWalletInventory.landSize',
      'landArea.id',
      'landArea.title'
    
    ])
    .where('con.id =:projectId', {projectId: ProjectId})
    .leftJoin('con.propertyWalletInventory', 'propertyWalletInventory')
    .leftJoin('propertyWalletInventory.landArea','landArea')


    const totalItems = await convoList.getCount();
    const Data = await paginate<PropertyWalletProject>(convoList, {
      limit,
      page,
      paginationType: PaginationTypeEnum.TAKE_AND_SKIP,
      metaTransformer: ({ currentPage, itemCount, itemsPerPage }) => {
        const totalPages = Math.ceil(totalItems / itemsPerPage);
        return {
          currentPage,
          itemCount,
          itemsPerPage,
          totalPages,
          
        }
      }
    })

    return { message: commonMessage.get, data: Data };

  } catch (error) {
    throw new InternalServerErrorException(error);
  }
}
























---------

  @Get('/getAvailableInventoriesByProjectId/:ProjectId')
  getAvailableInventoriesByProjectId(@Param('ProjectId') ProjectId: string, @Query('page', ParseIntPipe) page: number,
  @Query('limit', ParseIntPipe) limit: number,
  ) {
    return this.propertyWalletInventoryPlotService.getAvailableInventoriesByProjectId(+ProjectId, page, limit);
  }